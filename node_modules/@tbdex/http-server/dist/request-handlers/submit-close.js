import { CallbackError } from '../callback-error.js';
export async function submitClose(close, req, res, opts) {
    const { callback, exchangesApi } = opts;
    // Ensure that an exchange exists to be closed
    const exchange = await exchangesApi.getExchange({ id: close.exchangeId });
    if (exchange === undefined || exchange.messages.length === 0) {
        const errorResponse = { detail: `No exchange found for ${close.exchangeId}` };
        res.status(404).json({ errors: [errorResponse] });
        return;
    }
    // Ensure this exchange can be Closed
    if (!exchange.isValidNext(close.metadata.kind)) {
        const errorResponse = {
            detail: `cannot submit Close for an exchange where the last message is kind: ${exchange.latestMessage.metadata.kind}`
        };
        res.status(409).json({ errors: [errorResponse] });
        return;
    }
    // Ensure that Close is from either Alice or PFI
    const rfq = exchange.rfq;
    if (close.metadata.from === rfq.metadata.from && close.metadata.to === rfq.metadata.to) {
        // Alice may Close an exchange
    }
    else if (close.metadata.from === rfq.metadata.to && close.metadata.to === rfq.metadata.from) {
        // The PFI may Close an exchange
    }
    else {
        const errorResponse = {
            detail: `Only the creator and receiver of an exchange may close the exchange`
        };
        res.status(400).json({ errors: [errorResponse] });
        return;
    }
    if (!callback) {
        res.sendStatus(202);
        return;
    }
    try {
        await callback({ request: req, response: res }, close);
        res.sendStatus(202);
    }
    catch (e) {
        if (e instanceof CallbackError) {
            res.status(e.statusCode).json({ errors: e.details });
        }
        else {
            const errorDetail = { detail: 'Internal Server Error' };
            res.status(500).json({ errors: [errorDetail] });
        }
    }
}
//# sourceMappingURL=submit-close.js.map